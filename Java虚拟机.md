## JVM

### 1、GC是是什么/为什么要有GC

**简述Java垃圾回收机制**：

首先，垃圾是指内存中已经不再被使用的空间。

在Java中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行执行。在JVM中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，清扫那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。

**GC是什么？为什么要GC**：

GC，即Garbage Collection--垃圾收集。内存处理是我们容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法。我们不用担心内存管理，因为垃圾收集器会自动进行管理。~~要请求垃圾收集，可以调用下面的方法：System.gc() 或Runtime.getRuntime().gc() ，但JVM可以屏蔽掉显示的垃圾回收调用。~~垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的低优先级的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收，我们不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。

JVM中程序计数器、虚拟机栈、本地方法栈3个区域随线程而生随线程而灭。栈帧随着方法的进入和退出做入栈和出栈操作，实现了自动的内存清理。它们的内存分配和回收都具有确定性。因此，GC垃圾回收主要集中在**堆和方法区**，在程序运行期间，这部分内存的分配和使用都是**动态**的。



#### 补充：GC用到了哪些算法？分别应用到什么地方？

常见的回收算法有**标记清除算法、复制算法、标记整理算法、分代搜集算法**

##### **标记-清除算法：**

首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收所有未被标记的对象。

主要缺点：一个是**效率问题**，如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低；另外就是**内存空间的碎片化问题**，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致，当需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。

##### **复制算法（标记-复制）：**

将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当一块内存用完了，就将还存活着的对象复制到另外一块上，然后清理掉前一块。

每次对半区内存回收、分配内存时就不用考虑内存碎片等复杂情况，只要**移动堆顶指针，按顺序分配内存**即可，实现简单，运行高效。

缺点：将可用内存缩小为一半，性价比低；持续复制长生存期的对象则导致效率低下。

JVM堆中**新生代便采用复制算法**。堆分配结构图。

![image-20210306221730804](interviewImg/image-20210306221730804.png?lastModify=1630743326)

-   Eden（伊甸园）：这是对象最初诞生的区域，并且对大多数对象来说，这里是它们唯一存在过的区域。
-   Survivor（幸存者乐园）：从Eden幸存下来的对象会被挪到这里。
-   Tenured（老年代）：这是足够老的幸存对象的归宿。年轻代收集（Minor-GC）过程是不会触及这个地方的。当年轻代收集不能把对象放进老年代时，就会触发一次完全收集（Major-GC），这里可能还会牵扯到压缩，以便为大对象腾出足够的空间。

把新生代分为一块较大的Eden空间和两块较小的Survivor空间，每次分配内存只使用Eden和其中一块Survivor。发生垃圾收集时，将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上，然后直接清理掉Eden和已用过的那块Survivor空间。~~HotSpot虚拟机默认Eden和Survivor的大小比例时**8：1**，也即每次新生代中可用内存空间为整个新生代容量的90%（Eden的80%加上一个Survivor的10%），只有一个Survivor空间，即10%的新生代是会被浪费的。当然，98%的对象可被回收仅仅是普通场景下测得的数据，任何人都没有办法百分百保证每次回收都只有不多于10%的对象存活，当Survivor空间不足以容纳一次Minor GC之后存活的对象时，就需要依赖其他内存区域（实际上大多就是老年代）进行分配担保。~~

##### **标记-整理算法**：

标记过程与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

这种算法既不用浪费50%的内存，也解决了复制算法在对象存活率较高时的效率低下问题。

对象移动操作必须全程暂停用户应用程序才能进行，即Stop The World。最新的ZGC和Shenandoah收集器使用读屏障实现了整理过程与用户线程的并发执行）

标记清除是非移动式的回收算法，标记整理是移动式的回收算法。移动则内存回收时会更复杂，不移动则内存分配时会更复杂。

##### **分代搜集算法：**

分代收集理论--实质是一套符合大多数程序运行实际情况的经验法则，它建立在两个分代假说之上：

-   弱分代假说：绝大多数对象都是朝生夕灭的
-   强分代假说：熬过多次垃圾收集过程的对象就越难以消亡

这两个分代假说共同奠定了多款常用的垃圾收集器的一致的设计原则：收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区域之中存储。

困难：对象不是孤立的，对象之间会存在跨代引用。

-   第三条经验法则：跨代引用相对于同代引用来说仅占极少数。

这其实是前两条法则的隐含推论：存在相互引用关系的两个对象，是应该倾向于同时生存或者同时消亡的。依据这条假说，我们就不应该再为了少量的跨代引用去扫描整个老年代，也不必浪费空间专门记录每一个对象是否存在及存在哪些跨代引用，只需在新生代上建立一个全局的数据结构（“记忆集”，Remember Set），这个结构把老年代划分为若干小块，标识出老年代的哪一块内存会存在跨代引用。此后当发生Minor GC时，只有包含了跨代引用的小块内存里的对象才会被加入到GC Roots进行扫描。虽然这种方法需要在对象改变引用关系（如将自己或者某个属性赋值）时维护记录数据的正确性，会增加一些运行时的开销，但比起收集时扫描整个老年代来说仍然是划算的。

将Java的堆内存逻辑上分成两块，新生代和老年代，针对不同存活周期、不同大小的对象采取不同的垃圾回收策略。

在**新生代**中大多数对象都是瞬间对象，只有少量对象存活，复制较少对象即可完成清理，因此采用**复制算法**。而针对**老年代**中的对象，存活率较高，又没有额外的担保内存，因此采用**标记整理**算法。



#### 补充：Java会存在内存泄漏吗？

**内存泄漏是指不再被使用的对象或者变量一直被占据在内存中**。理论上来说，Java是有GC垃圾回收机制的，也就是说，不再被使用的对象，会被GC自动回收掉，自动从内存中清除。

但是，即使这样，Java也还是存在着内存泄漏的情况，**长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收**，这就是java中内存泄露的发生场景。



#### 补充：垃圾回收的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？

对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。

通常，GC采用有向图的方式记录和管理堆中的所有对象。通过这种方式确定哪些对象是“可达的”，哪些对象是“不可达的”。当GC确定一些对象为“不可达”时，GC就有责任回收这些内存空间。

可以调用下面的方法：System.gc() 或Runtime.getRuntime().gc()，来请求垃圾收集，但JVM可以屏蔽掉显示的垃圾回收调用，并不保证GC一定会执行。



#### 补充：Java中都有哪些引用类型？

传统的引用定义（JDK1.2版本之前）：如果reference类型的数据中存储的数值代表的是**另外一块内存的起始地址**，就称该reference数据是代表某块内存、某个对象的引用。JDK1.2版本后，对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用和虚引用。

-   强引用：是最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“Object obj = new Object()”这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。
-   软引用：用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。
-   弱引用：也是用来描述那些非必须的对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。
-   虚引用（幽灵引用/幻影引用）：是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。



### 2、java对象什么时候会被垃圾回收器判定为可回收/如何判断对象可以回收

判断对象是否存活一般有两种方式：

1.  引用计数方法：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，但无法解决对象相互循环引用的问题。
2.  可达性分析方法：此方法为解决引用计数方法的循环引用的问题。这里面需要引入一个概念--GC Roots，或者说是Tracing GC，这是一组“根集合”，也是一组引用集合，这个“根集合”就是一组必须活跃的引用。可达性分析方法的基本思路是，**通过一系列名为”GCRoots”的对象作为起始点，从这个被称为GC Roots的对象开始向下搜索，如果一个对象到GCRoots没有任何引用链相连时，则说明此对象不可用。**也即给定一个集合的引用作为根出发，通过引用关系遍历对象图，能被遍历到的（可到达的）对象就被判定为存活，没有被遍历到的就自然被判定为死亡。



#### 补充：Java中可以作为GC Roots的对象

1.  在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。
2.  在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。
3.  在方法区中常量引用的对象，譬如字符串常量池里的引用。
4.  在本地方法栈中JNI（即Native方法）引用的对象。
5.  Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointException、OutOfMemoryError）等，还有系统类加载器。
6.  所有被同步锁（synchronized关键字）持有的对象。
7.  反应Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。



#### ~~补充：JVM中的永久代中会发生垃圾回收吗~~

~~垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。如果仔细查看垃圾收集器的输出信息，就会发现**永久代也是被回收的**。这就是为什么正确的永久代大小对避免Full GC是非常重要的原因。~~

~~注：Java8中已经移除了永久代，新加了一个叫做元数据区的native内存区~~



#### 补充：内存分配策略

简述Java内存分配与回收策略以及Minor GC和Major GC

所谓自动内存管理，最终要解决的也就是**内存分配**和**内存回收**两个问题。

对象的内存分配通常是在 Java 堆上分配（随着虚拟机优化技术的诞生，某些场景下也会在栈上分配，后面会详细介绍），对象主要分配在新生代的 Eden 区，如果启动了本地线程缓冲，将按照线程优先在 TLAB 上分配。少数情况下也会直接在老年代上分配。总的来说分配规则不是百分百固定的，其细节取决于哪一种垃圾收集器组合以及虚拟机相关参数有关，但是虚拟机对于内存的分配还是会遵循以下几种「普世」规则：

**对象优先在Eden区分配**

多数情况，对象都在新生代 Eden 区分配。当 Eden 区分配没有足够的空间进行分配时，虚拟机将会发起一次 Minor GC。如果本次 GC 后还是没有足够的空间，则将启用分配担保机制在老年代中分配内存。

-   **Minor GC** 是指发生在新生代的 GC，因为 Java 对象大多都是朝生夕死，所有 Minor GC 非常频繁，一般回收速度也非常快。
-   **Major GC** 是指发生在老年代的 GC，出现了 Major GC 通常会伴随至少一次 Minor GC。Major GC 的速度通常会比 Minor GC 慢 10 倍以上。
-   **Full GC**：收集整个Java堆和方法区的垃圾收集。

**大对象直接进入老年代**

所谓大对象是指需要大量连续内存空间的对象，频繁出现大对象是致命的，会导致在内存还有不少空间的情况下提前触发 GC 以获取足够的连续空间来安置新对象。

前面我们介绍过新生代使用的是复制算法来处理垃圾回收的，如果大对象直接在新生代分配就会导致 Eden 区和两个 Survivor 区之间发生大量的内存复制。因此对于大对象都会直接在老年代进行分配。

**长期存活对象将进入老年代**

虚拟机采用分代收集的思想来管理内存，那么内存回收时就必须判断哪些对象应该放在新生代，哪些对象应该放在老年代。因此虚拟机给每个对象定义了一个对象年龄的计数器，如果对象在 Eden 区出生，并且能够被 Survivor 容纳，将被移动到 Survivor 空间中，这时设置对象年龄为 1。对象在 Survivor 区中每「熬过」一次 Minor GC 年龄就加 1，当年龄达到一定程度（默认 15） 就会被晋升到老年代。



#### 补充：堆内存常见参数配置

| 参数                       | 描述                                                         |
| -------------------------- | ------------------------------------------------------------ |
| -Xms                       | 堆内存初始大小，单位m、g                                     |
| -Xmx                       | 堆内存最大允许大小，一般不要大于物理内存的80%                |
| -XX:PermSize               | 非堆内存初始大小，一般应用设置初始化200m，最大1024m就够了    |
| -XX:MaxPermSize            | 非堆内存最大允许大小                                         |
| -XX:NewSize（-Xns）        | 年轻代内存初始大小                                           |
| -XX:MaxNewSize（-Xmn）     | 年轻代内存最大允许大小                                       |
| -XX:SurvivorRatio=8        | 年轻代中Eden区与Survivor区的容量比例值，默认为8，即8:1       |
| -Xss                       | 堆栈内存大小                                                 |
| -XX:NewRatio=老年代/新生代 | 设置老年代和新生代的大小比例                                 |
| -XX:+PrintGC               | jvm启动后，只要遇到GC就会打印日志                            |
| -XX:+PrintGCDetails        | 查看GC详细信息，包括各个区的情况                             |
| -XX:MaxDirectMemorySize    | 在NIO中可以直接访问**直接内存**，这个就是设置它的大小，不设置默认就是最大堆空间的值-Xmx |
| -XX:+DisableExplicitGC     | 关闭System.gc()                                              |
| -XX:MaxTenuringThreshold   | 垃圾可以进入老年代的年龄                                     |
| -Xnoclassgc                | 禁用垃圾回收                                                 |
| -XX:TLABWasteTargetPercent | TLAB占eden区的百分比，默认是1%                               |
| -XX:+CollectGen0First      | FullGC时是否先YGC，默认false                                 |



### 3、垃圾收集器//TODO

**stop-the-world**：

需要记住一个单词：`stop-the-world`。它会在任何一种GC算法中发生。stop-the-world 意味着**JVM因为需要执行GC而停止应用程序的执行**。当stop-the-world 发生时，**除GC所需的线程外，所有的线程都进入等待状态，直到GC任务完成**。GC优化很多时候就是减少stop-the-world 的发生。

![image-20210327210450545](interviewImg/image-20210327210450545.png?lastModify=1630743326)

新生代可配置的回收器：Serial、ParNew、Parallel Scavenge

老年代配置的回收器：CMS、Serial Old、Parallel Old

新生代和老年代区域的回收器之间进行连线，说明他们之间可以搭配使用。



#### 新生代垃圾回收器

##### Serial垃圾回收器

Serial收集器是最基本的、发展历史最悠久的收集器。俗称为：`串行回收器`，采用`复制算法`进行垃圾回收

“单线程”的意义不仅仅是说明它**只会使用一个处理器或一条收集线程去完成垃圾收集工作**，更重要的是强调在它进行垃圾收集时，**必须暂停其他所有工作线程**，直到它收集结束。

**特点**

串行回收器是指使用**单线程**进行垃圾回收的回收器。每次回收时，串行回收器只有一个工作线程。对于并行能力较弱的单CPU计算机来说，串行回收器的专注性和独占性往往有更好的性能表现。它存在Stop The World问题，即垃圾回收时，要停止程序的运行。

迄今为止，它依然是HotSpot虚拟机运行在客户端模式下的默认新生代收集器，有着优于其他收集器的地方，那就是**简单高效**（与其他收集器的单线程相比），对于内存资源受限的环境，它是所有收集器里**额外内存消耗最小的**；对于单核处理器或处理器核心数较少的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然**可以获得最高的单线程收集效率**。

使用`-XX:+UseSerialGC`参数可以设置新生代使用这个串行回收器



##### ParNew垃圾回收器

ParNew其实就是Serial的`多线程并行`版本，除了使用多线程之外，其余参数和Serial一模一样。俗称：`并行垃圾回收器`，采用`复制算法`进行垃圾回收

**特点**

ParNew默认开启的线程数与CPU数量相同，在CPU核数很多的机器上，可以通过参数`-XX:ParallelGCThreads`来设置线程数。

它是不少运行在服务端模式下的HotSpot虚拟机，尤其是JDK7之前的遗留系统中首选的新生代收集器，除了Serial之外，目前只有它能与CMS收集器配合工作。

自JDK9开始，ParNew加CMS收集器的组合不再是官方推荐的服务端模式下的收集器解决方案了。官方希望它能完全被G1所取代，甚至还取消了ParNew加Serial Old以及Serial加CMS这两组收集器组合的支持，并直接取消了`-XX:+UseParNewGC`参数，这意味着ParNew和CMS从此只能互相搭配使用，再也没有其他收集器能够和它们配合了。

ParNew收集器在单核心处理器的环境中绝对不会有比Serial收集器更好的效果，甚至由于存在线程交互的开销，该收集器在通过超线程技术实现的伪双核处理器环境中都不能百分之百保证超越Serial收集器。当然，随着可以被使用的处理器核心数量的增加，ParNew对于垃圾收集时系统资源的高效利用还是很有好处的。

它同样存在Stop The World问题。

使用`-XX:+UseParNewGC`参数可以设置新生代使用这个并行回收器



##### 补充：并行和并发

-   并行（Parallel）：并行描述的是**多条垃圾收集器线程之间的关系**，说明同一时间有多条这样的线程在协同工作，通常**默认此时用户线程是出于等待状态**。
-   并发（Concurrent）：并发描述的是**垃圾收集器线程与用户线程之间的关系**，说明**同一时间垃圾收集器线程与用户线程都在运行**。由于用户线程并未被冻结，所以程序仍然能响应服务请求，但由于垃圾收集器线程占用了一部分系统资源，此时应用程序的处理的吞吐量将受到一定影响。



##### Parallel Scavenge垃圾收集器

ParallelGC使用`复制算法`回收垃圾，也是多线程的。**CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量**。

**特点**

非常关注系统的吞吐量，`吞吐量`=`运行用户代码时间`/(`运行用户代码时间`+`运行垃圾收集时间`)

停顿时间越短就越适合需要与用户交互或需要保证服务响应质量的程序，良好的响应速度能提升用户体验；而高吞吐量则可以最高效率地利用处理器资源，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的分析任务。

`-XX:MaxGCPauseMillis`：设置最大垃圾收集停顿时间，可以把虚拟机在GC停顿的时间控制在MaxGCPauseMillis范围内，如果希望减少GC停顿时间可以将MaxGCPauseMillis设置的很小，但是会导致`GC频繁`，从而增加了GC的`总时间`，`降低`了`吞吐量`。所以需要根据实际情况设置该值。

`-Xx:GCTimeRatio`：设置吞吐量大小，它是一个0到100之间的整数，也就是垃圾收集时间占总时间的比率，相当于吞吐量的倒数，默认情况下他的取值是`99`，那么系统将花费不超过`1/(1+n)`的时间用于垃圾回收，也就是`1/(1+99)=1%`的时间，即允许最大1%的垃圾收集时间。

另外还可以指定`-XX:+UseAdaptiveSizePolicy`打开自适应模式，在这种模式下，新生代的大小、eden、from/to的比例，以及晋升老年代的对象年龄参数会被自动调整，以达到在堆大小、吞吐量和停顿时间之间的平衡点。这种调节方式称为垃圾收集器的**自适应的调节策略**。自适应调节策略也是Parallel Scavenge收集器区别于ParNew收集器的一个重要特性。

使用`-XX:+UseParallelGC`参数可以设置新生代使用这个并行回收器



#### 老年代垃圾回收器

##### Serial Old垃圾收集器

SerialOld是Serial回收器的`老年代`回收器版本，它同样是一个`单线程`回收器。使用算法：`标记-整理算法`

**用途**

主要意义是提供客户端模式下的HotSpot虚拟机使用。如果在服务端模式下，它主要有两种用途

-   在JDK1.5及之前的版本中与Parallel Scavenge收集器搭配使用，
-   作为CMS收集器发生失败时的后备预案，在并发收集发生Concurrent Mode Failure，则SerialOld将作为后备收集器。



##### Parallel Old垃圾收集器

老年代`ParallelOldGC`回收器也是一种多线程的回收器，和新生代的ParallelGC回收器一样，也是一种关注吞吐量的回收器，它使用了`标记-整理算法`进行实现。

在注重吞吐量或者处理器资源较为稀缺的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器这个组合。

`-XX:+UseParallelOldGc`进行设置老年代使用该回收器

`-XX:+ParallelGCThreads`也可以设置垃圾收集时的线程数量。



##### CMS垃圾收集器

CMS（Concurrent Mark Sweep）收集器是一种以**获得最短回收停顿时间**为目标的收集器，使用其的应用较为关注服务的响应速度，希望系统停顿时间尽可能短。基于`标记-清除`算法实现。整个运作过程分为四个步骤，包括：

1.  初始标记（CMS initial mark）
2.  并发标记（CMS concurrent mark）
3.  重新标记（CMS remark）
4.  并发清除（CMS concurrent sweep）

其中**初始标记、重新标记这两个步骤仍然需要“Stop The World”**。（1）初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快；（2）并发标记阶段就是从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是**不需要停顿用户进程**，可以与垃圾收集线程一起并发运行；（3）而重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录（并发的可达性分析--增量更新），这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短；（4）最后是并发清除阶段，清理删除掉标记阶段判断的已经死亡的对象，由于**不需要移动存活对象**，所以这个阶段也是可以与用户线程同时**并发**的。

由于在整个过程中耗时最长的并发标记和并发清除阶段中，垃圾收集器线程都可以与用户线程一起工作，所以从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。

**特点**：并发收集、低停顿，“并发低停顿收集器”

**缺点**：

-   首先，**CMS收集器对处理器资源非常敏感**。事实上，面向并发设计的程序都对处理器资源比较敏感。在并发阶段，它虽然不会导致用户线程停顿，但却会因为占用了一部分线程（或者说处理器的计算能力）而导致应用程序变慢，降低总吞吐量。CMS默认启动的回收线程数是（处理器核心数量+3）/4，也就是说，如果处理器核心数在四个或以上，并发回收时垃圾收集线程只占用不超过25%的处理器运算资源，并且会随着处理器核心数量的增加而下降。但是当处理器核心数量不足四个时，CMS对用户程序的影响就可能变得很大。如果应用程序本来的处理器负载就很高，还要分出一半的运算能力去执行收集器线程，就可能导致用户程序的执行速度忽然大幅降低。为了缓解这种情况，虚拟机提供了一种称为“**增量式并发收集器**”的CMS收集器变种，所做的事情和以前单核处理器年代PC机操作系统靠**抢占式多任务**来模拟多核并行多任务的思想一样，是在并发标记、清理的时候**让收集器线程、用户线程交替运行，尽量减少垃圾收集线程的独占资源的时间**，这样整个垃圾收集的过程会更长，但对用户程序的影响就会显得较少一些，直观感受是速度变慢的时间更多了，但速度下降幅度就没有那么明显。实践证明增量式的CMS收集器效果很一般，从JDK7开始，i-CMS模式已经被声明为“deprecated”，即已过时不再提倡用户使用，到JDK9发布后i-CMS模式被完全废弃。
-   **由于CMS收集器无法处理“浮动垃圾”，有可能出现“Concurrent Mode Failure”失败进而导致另一次完全“Stop The World”的Full GC的产生**。在CMS的并发标记和并发清理阶段，用户线程是还在继续运行的，程序在运行自然就还会伴随有新的垃圾对象不断产生，但这一部分垃圾对象是出现在标记过程结束以后，CMS无法在当次收集中处理掉它们，只好留待下一次垃圾收集时再清理掉。这一部分垃圾就称为“浮动垃圾”。同样也是由于在垃圾收集阶段用户线程还需要持续运行，那就还需要预留足够内存空间提供给用户线程使用，因此CMS收集器不能像其他收集器那样等待到老年代几乎完全被填满了再进行收集，必须预留一部分空间供并发收集时的程序运作使用。在JDK5的默认设置下，CMS收集器当老年代使用了68%的空间后就会被激活，这是一个偏保守的设置，如果在实际应用中老年代增长并不是太快，可以适当调高参数`-XX:CMSInitiatinOccupancyFraction`的值来提高CMS的触发百分比，降低内存回收频率，获得更好的性能。到了JDK6时，CMS收集器的启动阈值就已经默认提升至92%。但这又会更容易面临另一种风险：要是CMS运行期间预留的内存无法满足程序分配新对象的需要，就会出现一次“并发失败”（Concurrent Mode Failure），这时候虚拟机将不得不启动后备预案：冻结用户线程的执行，临时启用Serial Old收集器来重新进行老年代的垃圾收集，但这样停顿时间就很长了。所以参数`-XX:CMSInitiatinOccupancyFraction`设置得太高将会很容易导致大量的并发失败产生，性能反而降低，用户应在生成环境中根据实际应用情况来权衡设置。
-   **内存空间碎片问题**。CMS是基于标记-清除算法实现的收集器，意味着收集结束时会有大量空间碎片产生。空间碎片过多时，将会给大对象分配带来很大麻烦，往往会出现老年代还有很多剩余空间，但就是无法找到足够大的连续空间来分配当前对象，而不得不提前触发一次Full GC的情况。为了解决这个问题，CMS收集器提供了一个`-XX:+UseCMSCompactAtFullCollection`开关参数（默认是开启的，次参数从JDK9开始废弃），**用于在CMS收集器不得不进行Full GC时开启内存碎片的合并整理过程，由于这个内存整理必须移动存活对象，（在Shenandoah和ZGC出现前）是无法并发的**。这样空间碎片问题是解决了，但停顿时间又会变长，因此虚拟机设计者们还提供了另外一个参数`-XX:CMSFullGCsBeforeCompaction`（此参数从JDK9开始废弃），这个参数的作用是要求CMS收集器在执行过若干次（数量由参数值决定）不整理空间的Full GC之后 ，下一次进入Full GC前会先进行碎片整理（默认值为0，表示每次进入Full GC时都进行碎片整理）。



#### Garbage First收集器

Garbage First（简称G1）收集器开创了收集器**面向局部收集**的设计思路和**基于Region的内存布局形式**。G1是一款面向服务器端应用的垃圾收集器。作为CMS收集器的替代者和继承人，设计者们希望做出一款能够建立起“**停顿时间模型**”（Pause Prediction Model）的收集器，**停顿时间模型的意思是能够支持指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间大概率不超过N毫秒这样的目标**。

**停顿时间模型**：

之前出现的垃圾收集器，包括CMS在内，垃圾收集的目标范围要么是整个新生代（Minor GC），要么是整个老年代（Major GC），再要么就是整个Java堆（Full GC）。而**G1与它们不同，它可以面向堆内存任何部分来组成回收集（Collection Set，一般简称CSet）进行回收，衡量标准不在是它属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收收益最大，这就是G1收集器的Mixed GC模式**。·	

虽然G1也仍是遵循分代收集理论设计的，但其堆内存的布局与其他收集器有非常明显的差异：**G1不再坚持固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region），每一个Region都可以根据需要，扮演新生代的Eden空间，Survivor空间，或者老年代空间。收集器能够对扮演不同角色的Region采用不同的策略去处理**。Region中还有一类特殊的**Humongous区域，专门用来存储大对象**。G1认为只要**大小超过了一个Region容量一半的对象即可判定为大对象**。而对于那些超过了整个Region容量的超级大对象，将会被存放在N个连续的Humongous Region之中，G1的大多数行为都把Humongous Region作为老年代的一部分来进行看待。

虽然G1仍然保留新生代和老年代的概念，但**新生代和老年代不再是固定**的了，它们都**是一系列区域（不需要连续）的动态集合**。G1收集器之所以能建立可预测的停顿时间模型，是因为它**将Region作为单次回收的最小单元**，即每次收集到的内存空间都是Region大小的整数倍，这样可以有计划地避免在整个Java堆中进行全区域的垃圾收集。更具体的处理思路是让G1收集器去跟踪各个Region里面的垃圾堆积的“价值”大小，**价值即回收所获得的空间大小以及回收所需时间的经验值**，然后再后台维护一个**优先级列表**，每次根据用户设定允许的收集停顿时间（使用参数`-XX:MaxGCPauseMillis`指定，默认值是200毫秒），**优先处理回收价值收益最大的那些Region**。**这种使用Region划分内存空间，以及具有优先级的区域回收方式，保证了G1收集器在有限的时间内获取尽可能高的收集效率**。



**需要解决的问题**：

-   将Java堆分成多个独立Region后，Region里面存在的**跨Region引用对象如何解决**？使用**记忆集**避免全堆作为GC Roots扫描，但在G1收集器上记忆集的应用其实要复杂很多，**它的每个Region都维护有自己的记忆集，这些记忆集会记录下别的Region指向自己的指针，并标记这些指针分别在哪些卡页的范围之内**。G1的记忆集在存储结构的本质上是一种**哈希表**，**Key是别的Region的起始地址，Value是一个集合，里面存储的元素是卡表的索引号**。这种“双向“的卡表结构（卡表是”我指向谁“，这种结构还记录了”谁指向我“）比原来的卡表实现起来更复杂，同时由于Region数量比传统收集器的分代数量明显要多得多，因此G1收集器要比其他的传统垃圾收集器有着**更高的内存占用负担**。
-   在**并发标记阶段如何保证收集线程与用户线程互不干扰地运行**？**CMS收集器采用增量更新算法，而G1收集器则通过原始快照（SATB）算法实现的**。此外，**垃圾收集对用户线程的影响还体现在回收过程中新创建对象的内存分配上**，程序要继续运行就肯定会持续有新对象被创建，**G1为每一个Region设计了两个名为TAMS（Top at Mark Start）的指针，把Region中的一部分空间划分出来用于并发回收过程中的新对象分配，并发回收时新分配的对象地址都必须要在这两个指针位置以上**。G1收集器默认在这个地址以上的对象是被隐式标记过的，即**默认它们是存活的，不纳入回收范围**。与CMS中的”Concurrent Mode Failure“失败会导致Full GC类似，**如果内存回收的速度赶不上内存分配的速度，G1收集器也要被迫冻结用户线程执行，导致Full GC而产生长时间”Stop The World“**。
-   **怎样建立起可靠的停顿预测模型**？G1收集器的停顿预测模型是以**衰减均值**为理论基础来实现的，**在垃圾收集过程中，G1收集器会记录每个Region的回收耗时、每个Region记忆集里的脏卡数量等各个可测量的步骤花费的成本，并分析得出平均值、标准偏差、置信度等统计信息**。这里强调的”衰减平均值“是指**它会比普通的平均值更容易受到新数据的影响，平均值代表整体的平均值，但衰减平均值更准确地代表“最近的”平均状态**。换句话说，**Region的统计状态越新越能决定其回收的价值**。然后通过这些信息预测现在开始回收的话，由哪些Region组成回收集才可以在不超过期望停顿时间的约束下获得最高的收益。



**步骤**：G1收集器的运作过程大致可划分为一下四个步骤

-   **初始标记**（Initial Marking）：仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段**需要停顿用户线程，但耗时很短**，而且是**借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际并没有额外的停顿**。
-   **并发标记**（Concurrent Marking）：从GC Roots直接关联的对象开始对堆中对象进行**可达性分析**，递归扫描整个堆里的对象图，找出要回收的对象，这阶段**耗时较长，但可与用户程序并发执行**。当对象图扫描完成以后，还要重新处理SATB记录下的在并发时有引用变动的对象。
-   **最终标记**（Final Marking）：对**用户线程做另一个短暂的暂停**，用于处理并发阶段结束后仍遗留下来的最后那少量的SATB记录。
-   **筛选回收**（Live Data Counting and Evacuation）：**负责更新Region的统计数据，对各个Region的回收价值和成本进行排序**，根据用户所期望的停顿时间来制定回收计划，**可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个就Region的全部空间**。这里的操作**涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行完成的**。

**G1收集器除了并发标记外，其余阶段也是要完全暂停用户线程的，换言之，它并非纯粹地追求低延迟。**



与CMS相比，G1收集器的**优点**：

-   可以指定最大停顿时间
-   分Region的内存布局
-   按收益动态确定回收集
-   与CMS的”标记-清除“算法不同，**G1从整体来看是基于”标记-整理“算法实现的收集器，但从局部（两个Region之间）上看又是基于”标记-复制“算法实现**，无论如何，**这两种算法都意味着G1运作期间不会产生内存空间碎片，垃圾收集完成之后能提供规整的可用内存**。

**缺点**：

**G1无论是为了垃圾收集产生的内存占用还是程序运行时额外执行负载都要比CMS要高**。

就**内存占用**来说，**虽然G1和CMS都使用卡表来处理跨代指针，但G1的卡表实现更为复杂，而且堆中每个Region，无论扮演的是新生代还是老年代角色，都必须有一份卡表，这导致G1的记忆集（和其他内存消耗）可能会占整个堆容量的很多的内存空间**。

在**执行负载**的角度上，它们都使用到写屏障，CMS用**写后屏障**来更新维护卡表；而G1除了使用**写后屏障**来进行同样的（由于G1的卡表结果复杂，其实是更烦琐的）卡表维护操作外，为了实现原始快照搜索（SATB）算法，还需要使用**写前屏障**来跟踪并发时的指针变化情况。相比于增量更新算法，原始快照搜索能够减少并发标记和重新标记阶段的消耗，避免CMS那样在最终标记阶段停顿时间过长的缺点，但是在用户程序运行过程中确实会产生由跟踪引用变化带来的额外负担。由于G1对写屏障的复杂操作要比CMS消耗更多的运算资源，所以**CMS的写屏障实现是直接的同步操作**，而**G1就不得不将其实现为类似于消息队列的结构，把写前屏障和写后屏障中要做的事情都放到队列中，然后再异步处理**。



经验之谈：**在小内存应用上CMS的表现大概率仍然要优于G1，而在大内存应用上G1则大多能发挥其优势**。



#### 补充：Minor Gc、Major GC 和 Full GC 有什么不同

-   新生代 GC（Minor GC）:指发生新生代的的垃圾收集动作，Minor GC 非常频繁，回收速度一般也比较快。
-   老年代 GC（Major GC）:指发生在老年代的 GC，出现了 Major GC 经常会伴随至少一次的 Minor GC（并非绝对），Major GC 的速度一般会比 Minor GC 的慢 10 倍以上。
-   Full GC：收集整个Java堆和方法区的垃圾收集。



#### 补充：常用的GC调优策略

GC调优目的：将转移到老年代的对象数量降低到最小； 减少 GC 的执行时间。

`策略 1`：将新对象预留在新生代，由于 Major GC 的成本远高于 Minor GC，因此尽可能将对象分配在新生代是明智的做法，实际项目中根据 GC 日志分析新生代空间大小分配是否合理，适当通过“-Xmn”命令调节新生代大小，最大限度降低新对象直接进入老年代的情况。

`策略 2`：大对象进入老年代。所谓大对象是指需要大量连续内存空间的对象，频繁出现大对象是致命的，会导致在内存还有不少空间的情况下提前触发 GC 以获取足够的**连续空间**来安置新对象。因此，对于大对象，可以设置直接进入老年代（当然短命的大对象对于垃圾回收来说简直就是噩梦）。

`策略 3`：合理设置进入老年代对象的年龄，-XX:MaxTenuringThreshold 设置对象进入老年代的年龄大小，减少老年代的内存占用，降低 Major gc 发生的频率。

`策略 4`：设置稳定的堆大小，堆大小设置有两个参数：-Xms 初始化堆大小，-Xmx 最大堆大小。

`策略5`：注意： 如果满足下面的指标，则一般不需要进行 GC 优化：

>   MinorGC 执行时间不到50ms； Minor GC 执行不频繁，约10秒一次； Major GC 执行时间不到1s； Major GC 执行频率不算频繁，不低于10分钟1次。



### 4、Java内存区域

Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域。

![image-20210308224600866](interviewImg/image-20210308224600866.png?lastModify=1630743326)

这些组成部分一些事线程私有的，其他的则是线程共享的。

线程私有：程序计数器、虚拟机栈、本地方法栈

线程共享：堆、方法区



<img src="interviewImg/image-20210309193808824.png?lastModify=1630743326" alt="image-20210309193808824" style="zoom:50%;" />

<img src="interviewImg/image-20210309193902644.png?lastModify=1630743326" alt="image-20210309193902644" style="zoom:50%;" />



#### 程序计数器：

程序计数器是一块较小的内存空间，**可以看作是当前线程所执行的字节码的行号指示器**。**字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。**

另外，**为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。**

~~如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的字节码指令的地址；如果正在执行的是Natvie方法，这个计数器值则为空（Undefined）。~~

**程序计数器主要有两个作用：**

1.  字节码解释器通过改变程序计数器来依次读取指令，从而**实现代码的流程控制**，如：顺序执行、选择、循环、异常处理。
2.  在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。

**注意：程序计数器是唯一一个不会出现OutOfMemoryError的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。**



#### 虚拟机栈：

与程序计数器一样，Java虚拟机栈也是**线程私有**的，它的生命周期和线程相同。**虚拟机栈描述的是 Java 方法执行的内存模型：每个方法被执行的时候，Java虚拟机栈都会同步创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。**

Java 内存可以粗糙的区分为堆内存（Heap）和栈内存(Stack)，其中栈就是现在说的虚拟机栈，或者更多的情况下只是指虚拟机栈中局部变量表部分。

**局部变量表**存放了编译期可知的各种Java虚拟机**基本数据类型**（boolean、byte、char、short、int、float、long、double）、**对象引用**（reference类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和**returnAddress类型**（指向一条字节码指令的地址）。

~~这些数据类型在局部变量表中的存储空间以局部变量槽（Slot）来表示，其中64位长度的long和double类型的数据会占用2个变量槽，其余的数据类型只占用一个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法进行期间不会改变局部变量表的大小。注意，这里的“大小”是指变量槽的数量，虚拟机真正使用多大的内存空间（譬如按照一个变量槽占用32个比特、64个比特，或者更多）来实现一个变量槽，这是完全由具体的虚拟机实现自行决定的事情。~~

~~操作数栈(Operand Stack)也称作操作栈，是一个后入先出栈(LIFO)。随着方法执行和字节码指令的执行，会从局部变量表或对象实例的字段中复制常量或变量写入到操作数栈，再随着计算的进行将栈中元素出栈到局部变量表或者返回给方法调用者，也就是出栈/入栈操作。~~

~~动态链接：Java虚拟机栈中，每个栈帧都包含一个指向运行时常量池中该栈所属方法的符号引用，持有这个引用的目的是为了支持方法调用过程中的动态链接(Dynamic Linking)。~~ ~~方法返回地址：无论方法是否正常完成，都需要返回到方法被调用的位置，程序才能继续进行。~~

**Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError。**

-   **StackOverFlowError：** 如果线程请求栈深度超过当前Java虚拟机栈的最大深度的时候，就抛出StackOverFlowError异常。
-   **OutOfMemoryError：** 如果 Java 虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常。

HotSpot虚拟机的栈容量是不可以动态扩展的，所以在HotSpot虚拟机上是不会由于虚拟机栈无法扩展而导致OutOfMemoryError异常--只要线程申请栈空间成功了就不会有OOM，但是如果申请时就失败，仍然是会出现OOM异常的。



##### 补充：方法/函数如何调用（虚拟机栈）

栈区也叫虚拟机栈，是由一个一个的栈帧组成的后进先出的栈式结构，栈帧中存放**方法运行时产生的局部变量、方法出口等信息**。当调用一个方法时，虚拟机栈中就会创建一个栈帧存放这些数据，当方法调用完成时，栈帧消失，如果方法中调用了其他方法，则继续在栈顶创建新的栈帧。

Java 方法有两种返回方式：1、return语句；2、抛出异常

不管哪种返回方式都会导致栈帧被弹出。



#### 本地方法栈：

和虚拟机栈所发挥的作用非常相似，区别是： **虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的本地（Native） 方法服务。** 在 HotSpot 虚拟机中把本地方法栈和虚拟机栈合二为一。

本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。

方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种异常。

#### 堆：

Java 虚拟机所管理的内存中最大的一块，Java 堆是所有**线程共享**的一块内存区域，在虚拟机启动时创建。**此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。**

~~Java世界中“几乎”所有的对象都在堆中分配，但是，随着即使编译技术的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么绝对了。~~

Java 堆是垃圾收集器管理的主要区域，因此也被称作GC堆（Garbage Collected Heap）。从**回收内存**的角度看，由于现代垃圾收集器大部分都是基于**分代收集理论**设计的，所以Java堆还可以细分为：新生代和老年代：再细致一点有：Eden空间、From Survivor、To Survivor空间等。

![image-20210308234625169](interviewImg/image-20210308234625169.png?lastModify=1630743326)

如果从**分配内存**的角度看，所有线程共享的Java堆中可以划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB），以提升对象分配时的效率。不过无论从什么角度，无论如何划分，都不会改变Java堆中存储内容的共性，无论是哪个区域，存储的都只能是对象的实例。**将Java堆细分的目的只是更好地回收内存，或者更快地分配内存。**

Java虚拟机规范规定，Java堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。但对于大对象（典型的如数组对象），多数虚拟机实现出于实现简单、存储高效的考虑，很可能会要求连续的内存空间。当堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。



#### 方法区：

方法区与 Java 堆一样，是各个**线程共享**的内存区域，它**用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码缓存等数据**。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。

**方法区和永久代的关系**：《Java 虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。在不同的 JVM 上方法区的实现是不同的。 **方法区和永久代的关系很像 Java 中接口和类的关系，类实现了接口，而永久代就是 HotSpot 虚拟机对虚拟机规范中方法区的一种实现方式。** 也就是说，永久代是 HotSpot 的概念，方法区是 Java 虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现，其他的虚拟机实现并没有永久代这一说法。**JDK 1.8 的时候，方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。**

方法区与堆有很多共性：线程共享、内存不连续、可扩展、可垃圾回收，甚至可以不实现垃圾收集，同样当无法再扩展时会抛出OutOfMemoryError异常。

**相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载**，一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收有时又确实是必要的。

-   **运行时常量池**：

    运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有**常量池表**（用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中）。除了保存Class文件中描述的符号引用外，还会把符号应用翻译出来的直接引用也存储在运行时常量池中。

    既然运行时常量池时方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 异常。

    **JDK1.7之前运行时常量池包含的字符串常量池存放在方法区, 此时hotspot虚拟机对方法区的实现为永久代。JDK1.7 字符串常量池被从方法区拿到了堆中,运行时常量池剩下的东西还在方法区, 也就是hotspot中的永久代 。JDK1.8 hotspot移除了永久代用元空间(Metaspace)取而代之, 这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(Metaspace)，元空间也在直接内存中实现。**

    

#### 直接内存：

直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致OutOfMemoryError异常出现。

JDK1.4中新加入的 **NIO(New Input/Output) 类**，引入了一种基于**通道（Channel）** 与**缓存区（Buffer）** 的 I/O 方式，它可以直接使用Native函数库直接分配**堆外内存**，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为**避免了在 Java 堆和 Native 堆之间来回复制数据**。

本机直接内存的分配不会受到 Java 堆大小的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。



#### ~~补充：方法区/元空间常用参数~~

~~JDK 1.8 之前永久代还没被彻底移除的时候通常通过下面这些参数来调节方法区大小~~

```
-XX:PermSize=N //方法区 (永久代) 初始大小
-XX:MaxPermSize=N //方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen
```

~~JDK 1.8 的时候，方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。~~

```
-XX:MetaspaceSize=N //设置 Metaspace 的初始（和最小大小）
-XX:MaxMetaspaceSize=N //设置 Metaspace 的最大大小
```

~~与永久代很大的不同就是，如果不指定大小的话，随着更多类的创建，虚拟机会耗尽所有可用的系统内存。~~



#### 补充：为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?

1.  整个永久代有一个 JVM 本身设置固定大小上限，无法进行调整，而**元空间使用的是直接内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小**。

    当你元空间溢出时会得到如下错误： `java.lang.OutOfMemoryError: MetaSpace`

    你可以使用 `-XX：MaxMetaspaceSize` 标志设置最大元空间大小，默认值为 unlimited，这意味着它只受系统内存的限制。`-XX：MetaspaceSize` 调整标志定义元空间的初始大小，如果未指定此标志，则 Metaspace 将根据运行时的应用程序需求动态地重新调整大小。

2.  元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 `MaxPermSize` 控制了, 而由系统的实际可用空间来控制，这样能**加载的类就更多了**。

3.  在 JDK8，合并 HotSpot 和 JRockit 的代码时, JRockit 从来没有一个叫永久代的东西, 合并之后就没有必要额外的设置这么一个永久代的地方了。



### 5、HotSpot虚拟机对象探秘（对象的创建过程、对象的内存布局、对象的访问定位）

1.  **对象的创建过程**

    ![image-20210309124705365](interviewImg/image-20210309124705365.png?lastModify=1630743326)

    -   **类加载检查**：虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在**常量池**中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。

    -   **分配内存**：在**类加载检查**通过后，接下来虚拟机将为新生对象**分配内存**。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。**分配方式**有 **“指针碰撞”** 和 **“空闲列表”** 两种，**选择那种分配方式由 Java 堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定**。

        **内存分配的两种方式**：**“指针碰撞”** 和 **“空闲列表”** 

        -   指针碰撞：如果Java堆的内存是规整，即所有用过的内存放在一边，而空闲的的放在另一边。分配内存时将位于中间的指针指示器向空闲的内存移动一段与对象大小相等的距离，这样便完成分配内存工作。
        -   空闲列表：如果Java堆的内存不是规整的，则需要由虚拟机维护一个列表来记录那些内存是可用的，这样在分配的时候可以从列表中查询到足够大的内存分配给对象，并在分配后更新列表记录。

        选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是"标记-清除"，还是"标记-整理"（也称作"标记-压缩"），值得注意的是，复制算法内存也是规整的

        ![img](interviewImg/image-20210309124952443.png?lastModify=1630743326)

        **内存分配并发问题**：

        在创建对象的时候有一个很重要的问题，就是线程安全。因为在实际开发过程中，创建对象是很频繁的事情，哪怕只是修改一个指针所指向的位置，在并发情况下也是不安全的，可能出现正在给对象 A 分配内存，指针还没来得及修改，对象 B 又同时使用了原来的指针来分配内存的情况。作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：

        -   **CAS+失败重试：** CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。**虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。**
        -   **TLAB：** 为每一个线程预先在堆中分配一块儿内存，称为**线程本地分配缓冲区TLAB**（Thread Local Allocation Buffe，这是一个线程专用的内存分配区域），哪个线程要分配内存，就在哪个线程的TLAB上分配。当对象大于TLAB中的剩余内存或TLAB的内存已用尽时，再采用上述的CAS进行内存分配

    -   **初始化零值**：内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。

    -   **设置对象头**：初始化零值完成之后，**虚拟机要对对象进行必要的设置**，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希吗、对象的 GC 分代年龄等信息。 **这些信息存放在对象头中。** 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。

    -   **指定init方法**：在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始----构造函数，即Class文件中的`<init>` 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 `<init>` 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。

2.  **对象的内存布局**

    在 Hotspot 虚拟机中，对象在内存中的布局可以分为3块区域：**对象头**、**实例数据**和**对齐填充**。

    **Hotspot虚拟机的对象头包括两部分信息**，**第一部分用于存储对象自身的自身运行时数据**（哈希吗、GC分代年龄、锁状态标志等等），**另一部分是类型指针**，即对象指向它的类型元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例。

    **实例数据部分是对象真正存储的有效信息**，也是在程序中所定义的各种类型的字段内容。

    **对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。** 因为Hotspot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说就是对象的大小必须是8字节的整数倍。而对象头部分正好是8字节的倍数（1倍或2倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。

3.  **对象的访问定位**

    建立对象就是为了使用对象，我们的Java程序通过栈上的 reference 数据（引用）来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有**①使用句柄**和**②直接指针**两种：

    指针：指向对象，代表一个对象在内存中的起始地址。

    句柄：可以理解为指向指针的指针，维护着对象的指针。句柄不直接指向对象，而是指向对象的指针（句柄不发生变化，指向固定内存地址），再由对象的指针指向对象的真实内存地址。

    -   **句柄**：Java堆中会划分出一块内存来作为**句柄池**，引用中存储的就是对象的**句柄地址**，而句柄中包含了**对象实例数据**与**对象类型数据**各自的**具体地址**信息；

        ![image-20210309125828981](interviewImg/image-20210309125828981.png?lastModify=1630743326)

        **优势**：引用中存储的是**稳定**的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变**句柄中**的**实例数据指针**，而**引用**本身不需要修改。

    -   **直接指针**：如果使用直接指针访问，**引用**中存储的直接就是**对象的地址**，那么 Java 堆对像的布局中就必须考虑如何放置访问**类型数据**的相关信息。

        ![image-20210309125917103](interviewImg/image-20210309125917103.png?lastModify=1630743326)

    -   使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是非常可观的执行成本。HotSpot 中采用的就是这种方式。



#### 补充：String类和常量池

1.  **String对象的两种创建方式**

    ```
    String str1 = "abcd";//先检查字符串常量池中有没有"abcd"，如果字符串常量池中没有，则创建一个，然后 str1 指向字符串常量池中的对象，如果有，则直接将 str1 指向"abcd""；
    String str2 = new String("abcd");//堆中创建一个新的对象
    String str3 = new String("abcd");//堆中创建一个新的对象
    System.out.println(str1==str2);//false
    System.out.println(str2==str3);//false
    ```

    这两种不同的创建方法是有差别的，第一种方式是在常量池中拿对象，第二种方式是直接在堆内存空间创建一个新的对象。

    ![image-20210309203254338](interviewImg/image-20210309203254338.png?lastModify=1630743326)

    **记住：只要使用new方法，便需要创建新的对象。**

2.  **String 类型的常量池比较特殊。它的主要使用方法有两种**

    -   直接使用双引号声明出来的 String 对象会直接存储在常量池中。

    -   如果不是用双引号声明的 String 对象，可以使用 String 提供的 intern 方String.intern() 是一个 Native 方法，它的作用是：如果运行时常量池中已经包含一个等于此 String 对象内容的字符串，则返回常量池中该字符串的引用；如果没有，JDK1.7之前（不包含1.7）的处理方式是在常量池中创建与此 String 内容相同的字符串，并返回常量池中创建的字符串的引用，JDK1.7以及之后的处理方式是在常量池中记录此字符串的引用（对象的创建在堆中，引用指向的是堆中对象），并返回该引用。

        ```
        String s1 = new String("计算机");
        String s2 = s1.intern();
        String s3 = "计算机";
        System.out.println(s2);//计算机
        System.out.println(s1 == s2);//false，因为一个是堆内存中的String对象,一个是常量池中的String对象，
        System.out.println(s3 == s2);//true，因为两个都是常量池中的String对
        ```

3.  **String字符串拼接**

    ```
    String str1 = "str";
    String str2 = "ing";
          
    String str3 = "str" + "ing";//常量池中的对象
    String str4 = str1 + str2; //在堆上创建的新的对象   
    String str5 = "string";//常量池中的对象
    System.out.println(str3 == str4);//false
    System.out.println(str3 == str5);//true
    System.out.println(str4 == str5);//false
    ```

    ![image-20210309130441525](interviewImg/image-20210309130441525.png?lastModify=1630743326)

    尽量避免多个字符串拼接，因为这样会重新创建对象。如果需要改变字符串的化，可以使用 StringBuilder 或者 StringBuffer。



#### 补充：String s1 = new String("abc");这句话创建了几个对象？

**创建了两个对象**

```
String s1 = new String("abc");// 堆内存的地值值
String s2 = "abc";
System.out.println(s1 == s2);// 输出false,因为一个是堆内存，一个是常量池的内存，故两者是不同的。
System.out.println(s1.equals(s2));// 输出true
```

先有字符串"abc"放入常量池，然后 new 了一份字符串"abc"放入Java堆(字符串常量"abc"在编译期就已经确定放入常量池，而 Java 堆上的"abc"是在运行期初始化阶段才确定)，然后 Java 栈的 str1 指向Java堆上的"abc"。



#### 补充：8种基本类型的包装类和常量池

-   **Java 基本类型的包装类的大部分都实现了常量池技术，即 Byte,Short,Integer,Long,Character,Boolean；前面 4 种包装类默认创建了数值[-128，127] 的相应类型的缓存数据，Character创建了数值在[0,127]范围的缓存数据，Boolean 直接返回True Or False。如果超出对应范围仍然会去创建新的对象。**

-   **两种浮点数类型的包装类 Float,Double 并没有实现常量池技术。**

    ```
    Integer i1 = 33;
    Integer i2 = 33;
    System.out.println(i1 == i2);// 输出true
    Integer i11 = 333;
    Integer i22 = 333;
    System.out.println(i11 == i22);// 输出false
    Double i3 = 1.2;
    Double i4 = 1.2;
    System.out.println(i3 == i4);// 输出false
    ```

**Integer 缓存源代码：**

```
/**
*此方法将始终缓存-128到127（包括端点）范围内的值，并可以缓存此范围之外的其他值。
*/
    public static Integer valueOf(int i) {
        if (i >= IntegerCache.low && i <= IntegerCache.high)
            return IntegerCache.cache[i + (-IntegerCache.low)];
        return new Integer(i);
    }
```

**应用场景：**

1.  Integer i1=40；Java 在编译的时候会直接将代码封装成Integer i1=Integer.valueOf(40);，从而使用常量池中的对象。
2.  Integer i1 = new Integer(40);这种情况下会创建新的对象。

```
Integer i1 = 40;
Integer i2 = new Integer(40);
System.out.println(i1==i2);//输出false
```

**Integer比较更丰富的一个例子:**

```
Integer i1 = 40;
Integer i2 = 40;
Integer i3 = 0;
Integer i4 = new Integer(40);
Integer i5 = new Integer(40);
Integer i6 = new Integer(0);
  
System.out.println("i1=i2   " + (i1 == i2));
System.out.println("i1=i2+i3   " + (i1 == i2 + i3));
System.out.println("i1=i4   " + (i1 == i4));
System.out.println("i4=i5   " + (i4 == i5));
System.out.println("i4=i5+i6   " + (i4 == i5 + i6));   
System.out.println("40=i5+i6   " + (40 == i5 + i6));     
```

**结果**：

```
i1=i2   true
i1=i2+i3   true
i1=i4   false
i4=i5   false
i4=i5+i6   true
40=i5+i6   true
```

语句i4 == i5 + i6，因为+这个操作符不适用于Integer对象，首先i5和i6进行自动拆箱操作，进行数值相加，即i4 == 40。然后Integer对象无法与数值进行直接比较，所以i4自动拆箱转为int值40，最终这条语句转为40 == 40进行数值比较



### 6、类加载机制

**类的生命周期**

类的生命周期包括：加载、链接、初始化、使用和卸载

**类加载概机制念**

Java虚拟机把**描述类的数据**从Class文件加载到内存，并对数据进行**校验**、**转换解析**和**初始化**，最终形成可以**被虚拟机直接使用的Java类型**，这就是虚拟机的加载机制。Class文件由类装载器装载后，在JVM中将形成一份**描述Class结构的元信息对象**，通过该元信息对象可以获知**Class的结构信息：如构造函数，属性和方法等**，Java允许用户借由这个Class相关的元信息对象**间接调用Class对象的功能**，这里就是我们经常能见到的Class类。

**类加载过程**

![image-20210313150913202](interviewImg/image-20210313150913202.png?lastModify=1630743326)

类装载器就是寻找类的字节码文件，并构造出类在JVM内部表示的对象组件。在Java中，类装载器把一个类装入JVM中，要经过以下步骤：

1.  加载：查找和导入Class文件；
2.  链接：把类的二进制数据合并到JRE中；
    1.  校验：检查载入Class文件数据的正确性；
    2.  准备：给类的静态变量分配存储空间；
    3.  解析：将符号引用转成直接引用；
3.  初始化：对类的静态变量，静态代码块执行初始化操作

加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，类的加载过程必须按照这个顺序来按部就班地开始，而**解析**阶段则不一定，它在某些情况下可以在初始化阶段后再开始。因为java支持运行时绑定。

**Java程序可以动态扩展是由运行期动态加载和动态链接实现的**；比如：如果编写一个使用接口的应用程序，可以等到运行时再指定其实际的实现(多态)，解析过程有时候还可以在初始化之后执行；比如：动态绑定(多态) ，如上图所示，加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，类的加载过程必须按照这个顺序来按部就班地开始，而**解析阶段**则不一定，它在某些情况下可以在初始化阶段后再开始。 类的生命周期的每一个阶段通常都是互相交叉混合式进行的，通常会在一个阶段执行的过程中调用或激活另外一个阶段。

**1、装载（加载）**

类的装载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的**方法区**内，然后在**堆区**创建一个**java.lang.Class对象，用来封装类在方法区内的数据结构**。类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。

类加载器并不需要等到某个类被“首次主动使用”时再加载它，JVM规范允许类加载器在**预料某个类将要被使用时就预先加载它**，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器**必须在程序首次主动使用该类时才报告错误**（LinkageError错误）。如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误。

加载.class文件的方式有：1）从本地系统中直接加载；2）通过网络下载.class文件；3）从zip，jar等归档文件中加载.class文件；4）从专有数据库中提取.class文件；5）将Java源文件动态编译为.class文件

JVM虚拟机在类加载阶段需要完成一下三件事：

1.  通过一个**类的全限定名称**来获取定义此类的二进制字节流。
2.  将这个字节流所代表的**静态存储结构**转化为**方法区的运行时数据结构**。
3.  在java堆中生成一个代表这个类的java.lang.Class对象，作为方法区这些数据的访问入口。

相对于类加载过程的其他阶段，加载阶段是开发期相对来说可控性比较强，该阶段既可以使用系统提供的类加载器完成，也可以由用户自定义的类加载器来完成，开发人员可以通过定义自己的类加载器去控制字节流的获取方式。 加载阶段完成后，虚拟机外部的 二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个java.lang.Class类的对象，这样便可以通过该对象访问方法区中的这些数据。

**2、验证**

验证的目的是为了**确保Class文件中的字节流包含的信息符合当前虚拟机的要求**，而且不会危害虚拟机自身的安全。不同的虚拟机对类验证的实现可能会有所不同，但大致都会完成以下四个阶段的验证：**文件格式的验证**、**元数据的验证**、**字节码验证**和**符号引用验证**。

1.  文件格式的验证：**验证字节流是否符合Class文件格式的规范**，并且能被当前版本的虚拟机处理，该验证的**主要目的是保证输入的字节流能正确地解析并存储于方法区之内**。经过该阶段的验证后，字节流才会进入内存的方法区中进行存储，后面的三个验证都是基于方法区的存储结构进行的。
2.  元数据验证：**对类的元数据信息进行语义校验**（其实就是对类中的各数据类型进行语法校验），保证不存在不符合Java语法规范的元数据信息。
3.  字节码验证：该阶段验证的主要工作是**进行数据流和控制流分析，对类的方法体进行校验分析**，以保证被校验的类的方法在运行时不会做出危害虚拟机安全的行为。
4.  符号引用验证：这是最后一个阶段的验证，它发生在虚拟机将符号引用转化为直接引用的时候（解析阶段中发生该转化），主要是**对类自身以外的信息（常量池中的各种符号引用）进行匹配性的校验**。

**3、准备**

准备阶段是**正式为类变量（即static修饰的字段变量）分配内存并设置类变量初始值的阶段**（如static int i=5;这里只将i初始化为0，至于5的值将在初始化时赋值），这里不包含用**final修饰的static**，因为final在编译的时候就会分配了，注意这里不会为**成员变量**分配初始化，**类变量**都将在**方法区**中进行分配，而**成员变量**会随着对象一起分配到**堆**中。 注：

1.  **内存分配的对象**。Java 中的变量有**类变量**和**成员变量**两种类型，类变量指的是被 static 修饰的变量，而其他所有类型的变量都属于成员变量。在准备阶段，JVM只会为类变量分配内存，而不会为成员变量分配内存。
2.  **初始化的类型**。在准备阶段，JVM 会为类变量分配内存，并为其初始化。但是这里的初始化指的是为变量赋予 Java 语言中该数据类型的零值（即默认值，如0、0L、null、false等），而不是用户代码里初始化的值。

**4、解析**

解析阶段JVM 针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符 7 类引用进行解析。这个阶段的主要任务是虚拟机**将其在常量池内的符号引用替换为内存中的直接引用**。

**符号引用**（Symbolic Reference）：符号引用**以一组符号来描述所引用的目标**，符号引用可以是**任何形式的字面量**，符号引用**与虚拟机实现的内存布局无关**，**引用的目标并不一定已经在内存中**。

**直接引用**（Direct Reference）：直接引用可以是**直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄**。直接引用是**与虚拟机实现的内存布局相关的**，同一个符号引用在不同的虚拟机实例上翻译出来的直接引用一般都不相同，如果有了直接引用，那**引用的目标必定已经在内存中存在**。

1.  类或接口的解析：判断所要转化成的直接引用是对**数组类型**，还是**普通的对象类型**的引用，从而进行不同的解析。
2.  字段解析：对字段进行解析时，会先在本类中查找是否包含有简单名称和字段描述符都与目标相匹配的字段，如果有，则查找结束；如果没有，则会按照继承关系**从上往下递归搜索**该类所实现的各个接口和它们的父接口，还没有，则按照继承关系从上往下递归搜索其父类，直至查找结束。
3.  类方法解析：对类方法的解析与对字段解析的搜索步骤差不多，只是多了**判断该方法所处的是类还是接口**的步骤，而且对类方法的匹配搜索，是**先搜索父类，再搜索接口**。
4.  接口方法解析：与类方法解析步骤类似，只是**接口不会有父类**，因此，**只递归向上搜索父接口**就行了。

**5、初始化**

类初始化阶段是类加载过程的最后一步，前面的类加载过程中，除了加载（Loading）阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才**真正开始执行类中定义的Java程序代码**。这个方法不需要定义，是javac编译器自动收集类中所有类变量的赋值动作和静态代码块中的语句合并来的。 初始化，**为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化**。在Java中对类变量进行初始值设定有两种方式：

1.  定义静态变量时指定初始值。如 private static String x=“123”;
2.  在静态代码块里为静态变量赋值。如 static{ x=“123”; }

**JVM初始化步骤**：

1.  假如这个类还没有被加载和连接，则程序先加载并连接该类
2.  假如该类的直接父类还没有被初始化，则先初始化其直接父类
3.  假如类中有初始化语句，则系统依次执行这些初始化语句

**初始化阶段时执行类构造器方法的过程**：

1.  **类构造器方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的**，编译器收集的顺序由语句在源文件中出现的顺序所决定。
2.  **类构造器方法与类的构造函数不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的类构造器方法执行之前，父类的类构造器方法已经执行完毕**，因此在虚拟机中第一个执行的类构造器方法的类一定是java.lang.Object。
3.  由于父类的类构造器方法方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作。
4.  类构造器方法对于类或者接口来说并**不是必需的**，如果一个类中没有静态语句块也没有对类变量的赋值操作，那么编译器可以不为这个类生成类构造器方法。
5.  接口中可能会有变量赋值操作，因此**接口也会生成类构造器方法**。但是接口与类不同，**执行接口的类构造器方法不需要先执行父接口的类构造器方法**。只有当父接口中定义的变量被使用时，父接口才会被初始化。另外，**接口的实现类在初始化时也不会执行接口的类构造器方法**。
6.  虚拟机会保证一个类的类构造器方法在多线程环境中**被正确地加锁和同步**。如果有多个线程去同时初始化一个类，那么只会有一个线程去执行这个类的类构造器方法，其它线程都需要阻塞等待，直到活动线程执行类构造器方法完毕。如果在一个类的类构造器方法中有耗时很长的操作，那么就可能造成多个进程阻塞。

**6、卸载**

在以下情况的时候，Java虚拟机会结束生命周期 

1.  执行了System.exit()方法 
2.  程序正常执行结束
3.  程序在执行过程中遇到了异常或错误而异常终止 
4.  由于操作系统出现错误而导致Java虚拟机进程终止



#### 补充：何时开始类的初始化

什么情况下需要开始类加载过程的第一个阶段:"加载"。虚拟机规范中并没强行约束，这点可以交给虚拟机的的具体实现自由把握，但是对于初始化阶段虚拟机规范是严格规定了如下几种情况，如果类未初始化会对类进行初始化。

1.  创建类的实例
2.  访问类的静态变量(除常量【被final修辞的静态变量】原因:常量是一种特殊的变量，因为编译器把他们当作值(value)而不是域(field)来对待。**如果你的代码中用到了常变量(constant variable)，编译器并不会生成字节码来从对象中载入域的值，而是直接把这个值插入到字节码中**。这是一种很有用的优化，但是如果你需要改变final域的值那么每一块用到那个域的代码都需要重新编译。
3.  访问类的静态方法
4.  反射如(Class.forName("my.xyz.Test"))
5.  当初始化一个类时，发现其父类还未初始化，则先出发父类的初始化
6.  虚拟机启动时，定义了main()方法的那个类先初始化
7.  以上情况称为对一个类进行“主动引用”，除此种情况之外，均不会触发类的初始化，称为“被动引用” 接口的加载过程与类的加载过程稍有不同。**接口中不能使用static{}块**。当一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有真正在使用到父接口时（例如引用接口中定义的常量）才会初始化。

**被动引用的例子**

1.  子类调用父类的静态变量，子类不会被初始化。只有父类被初始化。对于静态字段，只有直接定义这个字段的类才会被初始化.
2.  通过数组定义来引用类，不会触发类的初始化
3.  访问类的常量，不会初始化类

```
class SuperClass {  
    static {  
        System.out.println("superclass init");  
    }  
    public static int value = 123;  
}  
  
class SubClass extends SuperClass {  
    static {  
        System.out.println("subclass init");  
    }  
}  
  
public class Test {  
    public static void main(String[] args) {  
        System.out.println(SubClass.value);// 被动应用1  
        SubClass[] sca = new SubClass[10];// 被动引用2  
    }  
} 
```

程序运行输出 superclass init 123 从上面的输入结果证明了被动引用1与被动引用2

```
class ConstClass {  
    static {  
        System.out.println("ConstClass init");  
    }  
    public static final String HELLOWORLD = "hello world";  
}  
  
public class Test {  
    public static void main(String[] args) {  
        System.out.println(ConstClass.HELLOWORLD);// 调用类常量  
    }  
}  
```

程序输出结果 hello world 从上面的输出结果证明了被动引用3

**题目分析**

```
class SingleTon {  
    private static SingleTon singleTon = new SingleTon();  
    public static int count1;  
    public static int count2 = 0;  
  
    private SingleTon() {  
        count1++;  
        count2++;  
    }  
  
    public static SingleTon getInstance() {  
        return singleTon;  
    }  
}  
  
public class Test {  
    public static void main(String[] args) {  
        SingleTon singleTon = SingleTon.getInstance();  
        System.out.println("count1=" + singleTon.count1);  
        System.out.println("count2=" + singleTon.count2);  
    }  
}  
```

分析：

1.  SingleTon singleTon = SingleTon.getInstance();调用了类的SingleTon调用了类的静态方法，触发类的初始化
2.  类加载的时候在准备过程中为类的静态变量分配内存并初始化默认值 singleton=null, count1=0, count2=0
3.  类初始化，为类的静态变量赋值和执行静态代码快。singleton赋值为new SingleTon()调用类的构造方法
4.  调用类的构造方法后count=1;count2=1
5.  继续为count1与count2赋值,此时count1没有赋值操作,所以count1为1,但是count2执行赋值操作就变为0



#### 补充：类初始化顺序

但了解清楚 域（fields，静态的还是非静态的）、块（block静态的还是非静态的）、不同类（子类和超类）和不同的接口（子接口，实现类和超接口）的初始化顺序也很重要类。下面是类初始化的一些规则：

1.  类从顶至底的顺序初始化，所以声明在顶部的字段的早于底部的字段初始化
2.  超类早于子类和衍生类的初始化
3.  如果类的初始化是由于访问静态域而触发，那么只有声明静态域的类才被初始化，而不会触发超类的初始化或者子类的初始化，即使静态域被子类或子接口或者它的实现类所引用
4.  接口初始化不会导致父接口的初始化。
5.  静态域的初始化是在类的静态初始化期间，非静态域的初始化时在类的实例创建期间。这意味这静态域初始化在非静态域之前。
6.  非静态域通过构造器初始化，子类在做任何初始化之前构造器会隐含地调用父类的构造器，他保证了非静态或实例变量（父类）初始化早于子类



#### 补充：类加载器

“**类加载器**”的任务是，根据一个类的**全限定名**来读取此类的二进制字节流到JVM中，然后转换为一个与目标类对应的java.lang.Class对象实例。在Java中，一个类用其**全限定类名**（包括包名和类名）作为标识；但在JVM中，一个类用其**全限定类名**和其**类加载器**作为其唯一标识。

虚拟机提供了3种类加载器，**启动（Bootstrap）类加载器**、**扩展（Extension）类加载器**、**应用程序（Application）类加载器**（也称系统类加载器）。

1.  启动（BootStrap）类加载器：用来加载java核心类库，无法被java程序直接引用

    Bootstrap类加载器主要加载的是JVM自身需要的类，这个加载器是使用C++语言实现的，是虚拟机自身的一部分，它负责将 <JAVA_HOME>/lib 路径下的核心类库，或 -Xbootclasspath 参数指定的路径下的jar包加载到内存中，注意由于虚拟机是按照文件名识别加载jar包的，如rt.jar，如果文件名不被虚拟机识别，即使把jar包丢到lib目录下也是没有作用的(出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类)。

    并不是继承自java.lang.ClassLoader，它没有父类加载器

    它加载`扩展类加载器`和`应用程序类加载器`，并成为他们的父类加载器

2.  扩展（Extension）类加载器：用来加载java的扩展库。Java虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载java类

    扩展类加载器是指 sun.misc.Launcher$ExtClassLoader类，由Java语言实现的，是Launcher的静态内部类，它负责加载 <JAVA_HOME>/lib/ext 目录下，或者系统变量 -Djava.ext.dir 指定路径中的类库，开发者可以直接使用标准扩展类加载器。

3.  应用程序（Application）类加载器：根据java应用的类路径（CLASSPATH）来加载java类。一般来说，java应用的类都是由它来完成加载

    也叫系统（System）类加载器，应用程序加载器 sun.misc.Launcher$AppClassLoader 类。它负责加载系统类路径java -classpath或-D java.class.path 指定路径下的类库，也就是我们经常用到的classpath路径，开发者可以直接使用应用程序类加载器，一般情况下该类加载是程序中默认的类加载器，通过ClassLoader#getSystemClassLoader()方法可以获取到该类加载器。

4.  在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，在必要时，我们还可以**自定义类加载器**（通过继承java.lang.ClassLoader类的方式实现）。比如用网络加载Java类，为了保证传输中的安全性，采用了加密操作，那么以上3种加载器就无法加载这个类，这时候就需要`自定义加载器`

需要注意的是，Java虚拟机对class文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象，而且加载某个类的class文件时，Java虚拟机采用的是**双亲委派模型（Parent Delegation Model）**。



##### 双亲委派机制

该机制要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。子类加载器和父类加载器不是以继承（Inheritance）的关系来实现，而是通过**组合**（Composition）关系来复用父加载器的代码。

**双亲委派模型的工作过程为：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的加载器都是如此，因此所有的类加载请求都会传给顶层的启动类加载器，只有当父加载器反馈自己无法完成该加载请求（该加载器的搜索范围中没有找到对应的类）时，子加载器才会尝试自己去加载。**

<img src="interviewImg/image-20210313155611010.png?lastModify=1630743326" alt="image-20210313155611010" style="zoom:50%;" />

使用这种模型来组织类加载器之间的关系的好处，是Java类随着它的类加载器一起具备了一种带有**优先级的层次关系**。通过这种层级关系可以**避免类的重复加载**，当父加载器已经加载了该类时，子加载器就不会再加载一次。例如java.lang.Object类，无论哪个类加载器去加载该类，最终都是由启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。



##### 反向委派机制

在Java应用中存在着很多服务提供者接口（Service Provider Interface，SPI），这些接口允许第三方为它们提供实现，~~如常见的 SPI 有 JDBC、JNDI等，这些 SPI 的接口属于 Java 核心库，一般存在rt.jar包中，~~由Bootstrap类加载器加载。而Bootstrap类加载器无法直接加载SPI的实现类，同时由于双亲委派模式的存在，Bootstrap类加载器也无法反向委托AppClassLoader加载器SPI的实现类。在这种情况下，我们就需要一种特殊的类加载器来加载第三方的类库，而**线程上下文类加载器（双亲委派模型的破坏者）**就是很好的选择。

从图可知rt.jar核心包是有Bootstrap类加载器加载的，其内包含SPI核心接口类，由于SPI中的类经常需要调用外部实现类的方法，而jdbc.jar包含外部实现类(jdbc.jar存在于classpath路径)无法通过Bootstrap类加载器加载，因此只能委派线程上下文类加载器把jdbc.jar中的实现类加载到内存以便SPI相关类使用。显然这种线程上下文类加载器的加载方式破坏了“双亲委派模型”，它在执行过程中抛弃双亲委派加载链模式，**使程序可以逆向使用类加载器**，当然这也使得Java类加载器变得更加灵活。

<img src="interviewImg/image-20210321120954462.png?lastModify=1630743326" alt="image-20210321120954462" style="zoom:50%;" />

-   **沙箱安全机制**

    自定义 String 类，但是在加载自定义 String 类的时候会率先使用启动类加载器加载，而启动类加载器在加载的过程中会先加载 JDK 自带的文件（rt.jar 包中的 java\lang\String.class），报错信息说没有 main 方法就是因为加载的 rt.jar 包中的 String 类。这样可以保证对 Java 核心源代码的保护，这就是沙箱安全机制。



**类加载器详解**

下面我们从代码层面了解几个Java中定义的类加载器及其双亲委派模式的实现，它们类图关系如下：

<img src="interviewImg/image-20210313160238199.png?lastModify=1630743326" alt="image-20210313160238199" style="zoom:50%;" />

顶层的类加载器是ClassLoader类，它是一个抽象类，其后所有的类加载器都继承自ClassLoader（不包括启动类加载器），这里我们主要介绍ClassLoader中几个比较重要的方法。

-   loadClass(String)：该方法加载指定名称（包括包名）的二进制类型，该方法在JDK1.2之后不再建议用户重写，但用户可以直接调用该方法，loadClass()方法是ClassLoader类自己实现的，该方法中的逻辑就是双亲委派模式的实现，其源码如下，loadClass(String name, boolean resolve)是一个重载方法，resolve参数代表是否生成class对象的同时进行解析相关操作。

    ```
    protected Class<?> loadClass(String name, boolean resolve)
            throws ClassNotFoundException
        {
            synchronized (getClassLoadingLock(name)) {
                // First, check if the class has already been loaded
                // 先从缓存查找该class对象，找到就不用重新加载
                Class<?> c = findLoadedClass(name);
                if (c == null) {
                    long t0 = System.nanoTime();
                    try {
                        if (parent != null) {
                        //如果找不到，则委托给父类加载器去加载
                            c = parent.loadClass(name, false);
                        } else {
                        //如果没有父类，则委托给启动类加载器去加载
                            c = findBootstrapClassOrNull(name);
                        }
                    } catch (ClassNotFoundException e) {
                        // ClassNotFoundException thrown if class not found
                        // from the non-null parent class loader
                    }
    
                    if (c == null) {
                        // If still not found, then invoke findClass in order
                        // to find the class.
                        // 如果都没有找到，则通过自定义实现的findClass去查找并加载
                        long t1 = System.nanoTime();
                        c = findClass(name);
    
                        // this is the defining class loader; record the stats
                        sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                        sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                        sun.misc.PerfCounter.getFindClasses().increment();
                    }
                }
                // 是否需要在加载时进行解析
                if (resolve) {
                    resolveClass(c);
                }
                return c;
            }
        }
    ```

    当类加载请求到来时，先从缓存中查找该类对象，如果存在直接返回，如果不存在则交给该类加载器的父加载器去加载，倘若没有父加载则交给顶级启动类加载器去加载，最后倘若仍没有找到，则使用findClass()方法去加载。

-   findClass(String)：在JDK1.2之前，在JDK1.2之后已不再建议用户去覆盖loadClass() 方法，而是建议把自定义的类加载逻辑写在findClass() 方法中，从前面的分析可知，findClass()方法是在loadClass()方法中被调用的，当loadClass()方法中父加载器加载失败后，则会调用自己的 findClass() 方法来完成类加载，这样就可以保证自定义的类加载器也符合双亲委托模型。ClassLoader类中findClass()方法源码如下：

    ```
    protected Class<?> findClass(String name) throws ClassNotFoundException {
            throw new ClassNotFoundException(name);
        }
    ```

-   defineClass(String name, byte[] b, int off, int len)：defineClass()方法是用来将byte字节流解析成JVM能够识别的Class对象(ClassLoader中已实现该方法逻辑)，通过这个方法不仅能够通过class文件实例化class对象，也可以通过其他方式实例化class对象，如通过网络接收一个类的字节码，然后转换为byte字节流创建对应的Class对象，defineClass()方法通常与findClass()方法一起使用，一般情况下，在自定义类加载器时，会直接覆盖ClassLoader的findClass()方法并编写加载规则，取得要加载类的字节码后转换成流，然后调用defineClass()方法生成类的Class对象，URLClassLOader中findClass代码如下：

    ```
    protected Class<?> findClass(final String name)
            throws ClassNotFoundException
        {
            final Class<?> result;
            try {
                result = AccessController.doPrivileged(
                    new PrivilegedExceptionAction<Class<?>>() {
                        public Class<?> run() throws ClassNotFoundException {
                            String path = name.replace('.', '/').concat(".class");
                            Resource res = ucp.getResource(path, false);
                            if (res != null) {
                                try {
                                    return defineClass(name, res);
                                } catch (IOException e) {
                                    throw new ClassNotFoundException(name, e);
                                }
                            } else {
                                return null;
                            }
                        }
                    }, acc);
            } catch (java.security.PrivilegedActionException pae) {
                throw (ClassNotFoundException) pae.getException();
            }
            if (result == null) {
                throw new ClassNotFoundException(name);
            }
            return result;
        }
    ```

-   resolveClass(Class≺?≻ c)：该方法可以使类的Class对象创建完成同时被解析。前面我们说链接阶段主要是对字节码进行验证，为类变量分配内存并设置初始值同时将字节码文件中的符号引用转换为直接引用。

上述4个方法是ClassLoader类中的比较重要且常用的方法。SercureClassLoader 扩展了 ClassLoader，新增了几个与使用相关的代码源(对代码源的位置及其证书的验证)和权限定义类验证(主要指对class源码的访问权限)的方法，一般我们不会直接跟这个类打交道，更多是与它的子类 URLClassLoader 有所关联，前面说过，ClassLoader是一个抽象类，很多方法是空的没有实现，比如 findClass()、findResource()等。而URLClassLoader这个实现类为这些方法提供了具体的实现。

<img src="interviewImg/image-20210313161201357.png?lastModify=1630743326" alt="image-20210313161201357" style="zoom:50%;" />

这里额外介绍一下 **sun.misc.URLClassPath** 类，通过这个类就可以找到要加载的字节码流，也就是说URLClassPath类负责找到要加载的字节码，再读取成字节流，如 URLClassLoader中findClass代码中有下面这句：`Resource res = ucp.getResource(path, false);`

这里的 ucp 就是 URLClassPath。如上类图所示，URLClassPath 有3个内部类，分别是FileLoader、JarLoader、Loader，加载的字节码流的具体工作就是由这些内部类完成。至于如何分配，在创建URLClassPath对象时，会根据传递过来的URL数组中的路径判断是文件还是jar包，然后根据不同的路径创建FileLoader或者JarLoader或默认Loader类。

了解完URLClassLoader后接着看看剩余的两个类加载器，即拓展类加载器ExtClassLoader和应用程序类加载器AppClassLoader，这两个类都继承自URLClassLoader，是sun.misc.Launcher的静态内部类。sun.misc.Launcher主要被系统用于启动主应用程序，ExtClassLoader和AppClassLoader都是由sun.misc.Launcher创建的，其类主要类结构如下：

<img src="interviewImg/image-20210313161537380.png?lastModify=1630743326" alt="image-20210313161537380" style="zoom:50%;" />

它们间的关系正如前面所阐述的那样，同时我们发现ExtClassLoader并没有重写loadClass()方法，这足矣说明其遵循双亲委派模式，而AppClassLoader重载了loadCass()方法，但最终调用的还是父类loadClass()方法，因此依然遵守双亲委派模式。



**类加载器之间的关系**

并非指继承关系，主要可以分为以下4点：

-   启动类加载器，由C++实现，没有父类。
-   扩展类加载器(ExtClassLoader)，由Java语言实现，父类加载器为null
-   系统类加载器(AppClassLoader)，由Java语言实现，父类加载器为ExtClassLoader
-   自定义类加载器，在没有指定的情况下，父类加载器默认为当前系统加载器，即 AppClassLoader。



**自定义类加载器**

实现自定义类加载器需要继承ClassLoader或者URLClassLoader，继承ClassLoader则需要自己重写findClass()方法并编写加载逻辑，继承URLClassLoader则可以省去编写findClass()方法以及class文件加载转换成字节码流的代码。那么编写自定义类加载器的意义何在呢？

-   当class文件不在ClassPath路径下，默认系统类加载器无法找到该class文件，在这种情况下我们需要实现一个自定义的ClassLoader来加载特定路径下的class文件生成class对象。
-   当一个class文件是通过网络传输并且可能会进行相应的加密操作时，需要先对class文件进行相应的解密后再加载到JVM内存中，这种情况下也需要编写自定义的ClassLoader并实现相应的逻辑。
-   当需要实现热部署功能时(一个class文件通过不同的类加载器产生不同class对象从而实现热部署功能)，需要实现自定义ClassLoader的逻辑。



**注：在JVM中表示两个class对象是否为同一个类对象存在两个必要条件：**

1.  类的完整类名必须一致，包括包名。
2.  加载这个类的ClassLoader(指ClassLoader**实例对象**)必须相同。

也就是说，在JVM中，即使这个两个类对象(class对象)来源同一个Class文件，被同一个虚拟机所加载，但只要加载它们的ClassLoader实例对象不同，那么这两个类对象也是不相等的。



#### 补充：ClassLoader 隔离问题

**有没有可能同时存在两个包名和类名完全一致的类？**

 JVM 及 Dalvik 对类唯一的识别是 ClassLoader id + PackageName + ClassName，所以一个运行程序中是有可能存在两个包名和类名完全一致的类的。并且如果这两个”类”不是由一个 ClassLoader 加载，是无法将一个类的示例强转为另外一个类的，这就是 ClassLoader 隔离。 当碰到这种问题时可以通过 instance.getClass().getClassLoader(); 得到 ClassLoader，看 ClassLoader 是否一样。



#### 补充：能不能自己写个类叫java.lang.System？

通常不可以，但可以采取另类方法达到这个需求。 解释：为了不让我们写System类，类加载采用委托机制，这样可以保证父亲们（父类加载器）优先，父亲们能找到的类，儿子（子类加载器）就没有机会加载。而System类是Bootstrap加载器加载的，就算自己重写，也总是使用Java系统提供的System，自己写的System类根本没有机会得到加载。

但是，我们可以**自己定义一个类加载器**来达到这个目的，**为了避免双亲委托机制，这个类加载器也必须是特殊的**。由于系统自带的三个类加载器都加载特定目录下的类，如果我们自己的类加载器放在**一个特殊的目录**，那么系统的加载器就无法加载，也就是最终还是由我们自己的加载器加载。



### 7、反射 //TODO

Java 反射机制是在运行状态中，**对于任意一个类，都能够获得这个类的所有属性和方法**，**对于任意一个对象都能够调用它的任意一个属性和方法**。这种在**运行时动态的获取信息以及动态调用对象的方法**的功能称为Java 的反射机制。

在Java中用来表示**运行时类型信息**的对应类就是Class类（java.lang.Class），在Java中每个类都有且只有一个Class对象，每当我们编写并且编译一个新创建的类就会产生一个对应的Class对象，这个Class对象保存在同名的.class文件里(编译后的字节码文件保存的就是Class对象)。当我们new一个新对象或者引用静态成员变量时，JVM中的类加载器子系统，会将对应的Class对象加载到JVM中，然后JVM再根据这个类型信息相关的Class对象，创建我们需要的实例对象或者提供静态变量的引用值。

-   Class类也是类的一种，只有一个私有构造函数，因此只能有jvm创建和加载
-   每个类被编译后会产生一个Class对象，其表示的是该类的类型信息，而且这个Class对象保存在同名.class的文件中(字节码文件)
-   每个通过关键字class标识的类，在内存中有且只有一个与之对应的Class对象来描述其类型信息，无论创建多少个实例对象，其依据的都是同一个Class对象。

Java反射的主要组成部分有4个：

-   **Class**：任何运行在内存中的所有类都是该 Class 类的实例对象，每个 Class 类对象内部都包含了类的**所有信息**。
-   **Field**：描述一个类的**属性**，内部包含了类的属性的所有信息，例如**数据类型**，**属性名**，**访问修饰符**······
-   **Constructor**：描述一个类的**构造方法**，内部包含了构造方法的所有信息，例如**参数类型**，**参数名字**，**访问修饰符**······
-   **Method**：描述一个类的**所有方法**（包括抽象方法），内部包含了该方法的所有信息，与**Constructor**类似，不同之处是 Method 拥有**返回值类型**信息，因为构造方法是没有返回值的。



### 8、JVM的主要组成部分及其作用

![image-20210313222940998](interviewImg/image-20210313222940998.png?lastModify=1630743326)

JVM包含两个子系统和两个组件，两个子系统为Class loader(类装载)、Execution engine(执行引擎)；两个组件为Runtime data area(运行时数据区)、Native Interface(本地接口)。

-   Class loader(类装载)：根据给定的全限定名类名(如：java.lang.Object)来装载class文件到Runtime data area中的method area。
-   Execution engine（执行引擎）：执行classes中的指令。
-   Native Interface(本地接口)：与native libraries交互，是其它编程语言交互的接口。
-   Runtime data area(运行时数据区域)：这就是我们常说的JVM的内存区域。

作用：首先通过编译器把 Java 代码转换成字节码，类加载器（ClassLoader）再把字节码加载到内存中，将其放在运行时数据区（Runtime data area）的方法区内，而字节码文件只是 JVM 的一套指令集规范，并不能直接交给底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。



### 9、浅拷贝和深拷贝

在 Java 中，除了**基本数据类型**（元类型）之外，还存在 类的实例对象这个**引用数据类型**。而一般使用 『 = 』号做赋值操作的时候。对于基本数据类型，实际上是拷贝的它的值，但是对于对象而言，其实赋值的只是这个对象的引用，将原对象的引用传递过去，他们实际上还是指向的同一个对象。

-   浅拷贝是按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。

    如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址 ，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。

-   深拷贝会拷贝所有的属性，并拷贝属性指向的动态分配的内存，也就是引用型对象数据。深拷贝相比于浅拷贝速度较慢并且花销较大。

序列化属于深拷贝



### 10、堆栈的区别

堆：主要用于存储**实例化的对象，数组**。用JVM动态分配内存空间。一个JVM只有一个堆内存，线程是可以**共享**数据的。注：静态变量放在方法区（详细见类加载机制），静态对象还是放在堆。

栈：主要用于存储**局部变量和对象的引用变量**，每个线程都会有一个独立的栈空间，所以线程之间是**不共享数据**的。

**Java中所有对象的存储空间都是在堆中分配的，但是这个对象的引用却是在栈中分配，也就是说在建立一个对象时从两个地方都分配内存，在堆中分配的内存实际建立这个对象，而在栈中分配的内存只是一个指向这个堆对象的指针（引用）而已。**

堆和栈的共同点和优缺点：

1.  栈（stack）与堆（heap）都是Java用来在RAM中存放数据的地方。与C++不同，Java自动管理栈和堆，程序员不能直接地设置栈或堆。
2.  栈的优势是，**存取速度比堆要快**，仅次于直接位于CPU中的寄存器。但缺点是，存在**栈中的数据大小与生存期必须是确定的，缺乏灵活性**。另外，**栈数据可以共享**（同一个线程）。堆的优势是可以**动态分配内存大小**，生存期也不必事先告诉编译器，Java的垃圾收集器会自动收走这些不再使用的数据。但缺点是，由于要运行时动态分配内存，**存取速度较慢**。
3.  Java中的数据类型有两种。一种是**基本类型**，共8种，即int，short，long，byte，float，double，boolean，char（注意，并没有String的基本类型）。这种类型的定义是通过诸如int a = 3；long b = 255L；的形式来定义的，称为自动变量。自动变量存的是字面值，不是类的实例，即不是类的引用，这里并没有类的存在。如int a = 3；这里的a是一个指向int类型的引用，指向3这个字面值。这些字面值的数据，由于大小可知，生存期可知（这些字面值固定定义在某个程序块里面，程序块退出后，字段值就消失了），出于追求速度的原因，就存在于栈中。栈有一个很重要的特殊性，就是存在栈中的数据可以共享。假设我们同时定义int a = 3；int b = 3；编译器先处理int a = 3；首先它会在栈中创建一个变量为a的引用，然后查找有没有字面值为3的内存地址，没找到，就开辟一个存放3这个字面值的地址，然后将a指向3的地址。接着处理int b = 3；在创建完b的引用变量后，由于在栈中已经有3这个字面值，便将b直接指向3的地址。这样，就出现了**a与b同时均指向3**的情况。特别注意的是，这种字面值的引用与类对象的引用不同。假定两个类对象的引用同时指向一个对象，如果一个对象引用变量修改了这个对象的内部状态，那么另一个对象引用变量也即刻反映出这个变化。相反，通过字面值的引用来修改其值，不会导致另一个指向此字面值的引用的值也跟着改变的情况。如上例，我们定义完a与b的值后，再令a=4；那么，b不会等于4，还是等于3。在编译器内部，遇到a=4；时，它就会重新搜索栈中是否有4的字面值，如果没有，重新开辟地址存放4的值；如果已经有了，则直接将a指向这个地址。因此a值的改变不会影响到b的值。另一种是**包装类数据**，如Integer，String，Double等相应的基本数据类型包装起来的类。这些类数据全部存在于堆中，Java用new()语句来显示地告诉编译器，在运行时才根据需要动态创建，因此比较灵活，但缺点是要占用更多的时间。

堆和栈的区别

1.  各司其职：最主要的区别就是栈内存用来存储局部变量和方法调用。而堆内存用来存储Java中的对象。无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中。
2.  独有还是共享：栈内存归属于单个线程，每个线程都会有一个内存，其存储的变量只能在其所属线程中可见，即栈内存可以理解成线程的私有内存。而堆内存中的对象对所有线程可见。堆内存中的对象可以被所有线程访问。
3.  异常错误：如果栈内存没有可用的空间存储方法调用和局部变量，JVM会抛出java.lang.StackOverFlowError。而如果是堆内存没有可用的空间存储生成的对象，JVM会抛出java.lang.OutOfMemoryError。
4.  空间大小：栈的内存要远远小于堆内存，如果你是用递归的话，那么你的栈很快就会充满。如果递归没有及时跳出，很可能发生StackOverFlowError问题。~~你可以通过-Xss选项设置栈内存的大小。-Xms选项可以设置堆的开始时的大小，-Xmx选项可以设置堆的最大值。~~



### 11、JVM调优的工具？

JDK 自带了很多监控工具，都位于 JDK 的 bin 目录下，其中最常用的是 jconsole 和 jvisualvm 这两款视图监控工具。

-   jconsole：用于对 JVM 中的内存、线程和类等进行监控；
-   jvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc 变化等



### 12、常用的JVM调优的参数有哪些？

-   -Xms2g：初始化推大小为 2g；
-   -Xmx2g：堆最大内存为 2g；
-   -XX:NewRatio=4：设置年轻的和老年代的内存比例为 1:4；
-   -XX:SurvivorRatio=8：设置新生代 Eden 和 Survivor 比例为 8:2；
-   –XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合；
-   -XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合；
-   -XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合；
-   -XX:+PrintGC：开启打印 gc 信息；
-   -XX:+PrintGCDetails：打印 gc 详细信息。